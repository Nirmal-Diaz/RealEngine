<!DOCTYPE html>
<html lang="en-us" xmlns="http://www.w3.org/1999/xhtml" style="height: 100%; width: 100%;">
<meta charset="UTF-8" />

<head>
    <title>RealEngine</title>
    <style>
        * {
            /* border: thin solid red; */
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            overflow: hidden;
            color: white;
            font-family: "Calibri";
            font-size: 30px;
        }

        body {
            height: 100%;
            width: 100%;
        }

        .canvas {
            position: absolute;

            height: 100%;
            width: 100%;

            background-color: black;
        }

        .interfaceDivision {
            position: absolute;

            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            align-items: center;

            height: 100%;
            width: 100%;
            padding-bottom: 100px;
        }

        .interfaceDivisionSector {
            overflow: auto;

            width: 80%;
            padding: 30px;

            border: 5px solid white;
            border-radius: 30px;
            background-color: rgba(0, 0, 0, 0.8);
        }

        @media (orientation: landscape) {
            .interfaceDivisionSector {
                height: 40%;
            }
        }

        @media (orientation: portrait) {
            .interfaceDivisionSector {
                height: auto;
            }
        }

        .title {
            margin-bottom: 30px;

            font-size: 50px;
        }

        .titleDescription {
            color: gray;
        }

        .inputContainer {
            width: 100%;
        }

        .display {
            width: 100%;

            font-size: 100px;
        }

        .input-range {
            width: 100%;
        }

        .input-check {
            margin-right: 30px;
            height: 70px;
            width: 70px;
        }

        .interfaceControlsSector {
            margin-top: 100px;
        }

        .button {
            margin: 0 15px 0 15px;
            height: 100px;
            width: 100px;

            border: 5px solid white;
            border-radius: 50%;
            background-color: rgba(0, 0, 0, 0.8);

            font-size: 50px;
        }
    </style>
    <script>
        //@ts-check
        let canvas, context2D;

        //The physicsEngine calculates motionVariables (i.e. s, v) based on passed time between two frames
        //Therefore it is required to keep track of time when the last frame was rendered
        let lastTime = new Date().getTime();

        const globalMotion = {
            accelerometer: new Accelerometer({ frequency: 16 }),
            accelerationScale: 500,
            xAcceleration: 0,
            yAcceleration: 0,
        };

        const objects = [];

        function getRandomColor() {
            return `rgb(${Math.floor(Math.random() * (255 - 150 + 1)) + 150}, ${Math.floor(Math.random() * (255 - 150 + 1)) + 150}, ${Math.floor(Math.random() * (255 - 150 + 1)) + 150}`;
        }

        function calculateMotionVariables(u = 0, a = 10, t = 1) {
            //Calculate displacement
            const s = (u * t) + (1 / 2 * a * t * t);
            //calculate end velocity
            const v = u + (a * t);
            return { displacement: s, velocity: v };
        }

        function calculateVelocity(u = 0, a = 10, s = 0) {
            return Math.sqrt((u * u) + (2 * a * s));
        }

        function calculateDisplacement(v = 0, u = 0, a = 10, t = 1) {
            return ((v * v) - (u * u)) / (2 * a);
        }

        function calculateVerticalMotion(timeDifference, object) {
            //After multiplying velocities by elasticConstant several times leads to NaN resulting as the velocity
            //That happens when the velocity is so tiny that it can be considered as 0
            if (isNaN(object.yVelocity)) {
                object.yVelocity = 0;
                object.yMotionAtRest = true;
            } else {
                if (object.yDirection === true) {
                    const motionVariables = calculateMotionVariables(object.yVelocity, globalMotion.yAcceleration, timeDifference);
                    let newYCoordinate = object.yCoordinate + motionVariables.displacement;
                    //This is where the object goes out of bounds at the bottom
                    if (newYCoordinate >= canvas.height - object.radius) {
                        newYCoordinate = canvas.height - object.radius;
                        object.yDirection = false;
                        //We don't know the end velocity(v) at the bottom boundary, but we know the displacement(s)
                        //And also to get the bounce velocity we have to multiply it with elasticConstant
                        object.yVelocity = calculateVelocity(object.yVelocity, globalMotion.yAcceleration, canvas.height - object.radius - object.yCoordinate) * object.elasticConstant;
                        //This is where the object reverses its direction due to deceleration in the mid-motion
                    } else if (motionVariables.velocity <= 0) {
                        //We don't know the displacement(s) to the turning point, but we know the end velocity(v) which is 0
                        object.yCoordinate = object.yCoordinate + calculateDisplacement(0, object.yVelocity, globalMotion.yAcceleration);
                        object.yVelocity = 0;
                        object.yDirection = false;
                        //This is for normal motion
                    } else {
                        //We just need to update the velocity
                        object.yVelocity = motionVariables.velocity;
                    }
                    //Update object's yCoordinate in the object object
                    object.yCoordinate = newYCoordinate;
                } else {
                    const motionVariables = calculateMotionVariables(object.yVelocity, -globalMotion.yAcceleration, timeDifference);
                    let newYCoordinate = object.yCoordinate - motionVariables.displacement;
                    //This is where the object goes out of bounds at the top
                    if (newYCoordinate <= object.radius) {
                        newYCoordinate = object.radius;
                        object.yDirection = true;
                        object.yVelocity = calculateVelocity(object.yVelocity, -globalMotion.yAcceleration, object.yCoordinate - object.radius) * object.elasticConstant;
                        //This is where the object reverses its direction due to deceleration in the mid-motion
                    } else if (motionVariables.velocity <= 0) {
                        object.yCoordinate = object.yCoordinate + calculateDisplacement(0, object.yVelocity, -globalMotion.yAcceleration);
                        object.yVelocity = 0;
                        object.yDirection = true;
                        //This is for normal motion
                    } else {
                        object.yVelocity = motionVariables.velocity;
                    }
                    //Update object's yCoordinate in the object object
                    object.yCoordinate = newYCoordinate;
                }
            }
        }

        function calculateHorizontalMotion(timeDifference, object) {
            if (isNaN(object.xVelocity)) {
                object.xVelocity = 0;
                object.xMotionAtRest = true;
            } else {
                if (object.xDirection === true) {
                    const motionVariables = calculateMotionVariables(object.xVelocity, globalMotion.xAcceleration, timeDifference);
                    let newXCoordinate = object.xCoordinate + motionVariables.displacement;
                    if (newXCoordinate >= canvas.width - object.radius) {
                        newXCoordinate = canvas.width - object.radius;
                        object.xDirection = false;
                        object.xVelocity = calculateVelocity(object.xVelocity, globalMotion.xAcceleration, canvas.width - object.radius - object.xCoordinate) * object.elasticConstant;
                    } else if (motionVariables.velocity <= 0) {
                        object.xCoordinate = object.xCoordinate + calculateDisplacement(0, object.xVelocity, globalMotion.xAcceleration);
                        object.xVelocity = 0;
                        object.xDirection = false;
                    } else {
                        object.xVelocity = motionVariables.velocity;
                    }
                    object.xCoordinate = newXCoordinate;
                } else {
                    const motionVariables = calculateMotionVariables(object.xVelocity, -globalMotion.xAcceleration, timeDifference);
                    let newXCoordinate = object.xCoordinate - motionVariables.displacement;
                    if (newXCoordinate <= object.radius) {
                        newXCoordinate = object.radius;
                        object.xDirection = true;
                        object.xVelocity = calculateVelocity(object.xVelocity, -globalMotion.xAcceleration, object.xCoordinate - object.radius) * object.elasticConstant;
                    } else if (motionVariables.velocity <= 0) {
                        object.xCoordinate = object.xCoordinate + calculateDisplacement(0, object.xVelocity, -globalMotion.xAcceleration);
                        object.xVelocity = 0;
                        object.xDirection = true;
                    } else {
                        object.xVelocity = motionVariables.velocity;
                    }
                    object.xCoordinate = newXCoordinate;
                }
            }
        }

        function animateObjects() {
            const currentTime = new Date().getTime();
            const timeDifference = (currentTime - lastTime) / 1000;
            lastTime = currentTime;

            //Calculate motion for each object and update variables
            for (let i = 0; i < objects.length; i++) {
                calculateHorizontalMotion(timeDifference, objects[i]);
                calculateVerticalMotion(timeDifference, objects[i]);
            }

            //Clear the canvas before rendering
            context2D.clearRect(0, 0, canvas.width, canvas.height);
            //Draw each object on the canvas
            for (let i = 0; i < objects.length; i++) {
                context2D.beginPath();
                context2D.arc(objects[i].xCoordinate, objects[i].yCoordinate, objects[i].radius, 0, 2 * Math.PI);
                context2D.fillStyle = objects[i].color;
                context2D.fill();
            }

            window.requestAnimationFrame(animateObjects);
        }

        function setViewport() {
            const canvasBoundingRect = canvas.getBoundingClientRect();
            canvas.height = canvasBoundingRect.height;
            canvas.width = canvasBoundingRect.width;
        }

        function initiate() {
            //Initialize global variables
            canvas = document.getElementById("canvas");
            context2D = canvas.getContext("2d");
            
            //Cache elements for event listeners
            const settingsDivision = document.getElementById("settingsDivision");
            const addObjectDivision = document.getElementById("addObjectDivision");
            const globalSettingsDivision = document.getElementById("globalSettingsDivision");

            const xVelocityContainer = document.getElementById("xVelocity");
            const yVelocityContainer = document.getElementById("yVelocity");
            const elasticConstantContainer = document.getElementById("elasticConstant");
            const radiusContainer = document.getElementById("radius");
            const realTimeAccelerationContainer = document.getElementById("realTimeAcceleration");
            const customXAccelerationContainer = document.getElementById("customXAcceleration");
            const customYAccelerationContainer = document.getElementById("customYAcceleration");
            const accelerationScaleContainer = document.getElementById("accelerationScale");

            //Add eventListeners
            window.addEventListener("resize", setViewport);

            //Access accelerometer using generic sensors API (can define polling rate)
            globalMotion.accelerometer.onreading = () => {
                globalMotion.xAcceleration = -globalMotion.accelerometer.x * globalMotion.accelerationScale;
                globalMotion.yAcceleration = globalMotion.accelerometer.y * globalMotion.accelerationScale;
            };
            
            //Access accelerometer using DOM'S ondevicemotion event (cannot define polling rate)
            // window.ondevicemotion = (event) => {
            //     globalMotion.xAcceleration = -event.accelerationIncludingGravity.x * globalMotion.accelerationScale;
            //     globalMotion.yAcceleration = event.accelerationIncludingGravity.y * globalMotion.accelerationScale;
            // }

            document.getElementById("showGlobalSettings").addEventListener("click", () => {
                settingsDivision.style.display = "none";
                globalSettingsDivision.style.display = "flex";
            });

            document.getElementById("showAddObject").addEventListener("click", () => {
                settingsDivision.style.display = "none";
                addObjectDivision.style.display = "flex";
            });

            document.getElementById("clearObjects").addEventListener("click", () => {
                objects.length = 0;
            });

            document.getElementById("addObject").addEventListener("click", () => {
                const object = {
                    xCoordinate: canvas.width / 2,
                    yCoordinate: canvas.height / 2,
                    xVelocity: parseInt(xVelocityContainer.firstElementChild.value),
                    yVelocity: parseInt(yVelocityContainer.firstElementChild.value),
                    xDirection: true,
                    yDirection: true,
                    elasticConstant: parseFloat(elasticConstantContainer.firstElementChild.value),
                    radius: parseInt(radiusContainer.firstElementChild.value),
                    color: getRandomColor()
                };

                objects.push(object);
                settingsDivision.style.display = "flex";
                addObjectDivision.style.display = "none";
            });

            document.getElementById("cancelAddObject").addEventListener("click", () => {
                settingsDivision.style.display = "flex";
                addObjectDivision.style.display = "none";
            });

            document.getElementById("applyGlobalSettings").addEventListener("click", () => {
                if (realTimeAccelerationContainer.firstElementChild.checked) {
                    globalMotion.accelerometer.start();
                } else {
                    globalMotion.accelerometer.stop();
                }

                globalMotion.xAcceleration = parseInt(customXAccelerationContainer.firstElementChild.value);
                globalMotion.yAcceleration = parseInt(customYAccelerationContainer.firstElementChild.value);
                globalMotion.accelerationScale = parseInt(accelerationScaleContainer.firstElementChild.value);

                settingsDivision.style.display = "flex";
                globalSettingsDivision.style.display = "none";
            });

            document.getElementById("cancelGlobalSettings").addEventListener("click", () => {
                settingsDivision.style.display = "flex";
                globalSettingsDivision.style.display = "none";
            });

            xVelocityContainer.firstElementChild.addEventListener("input", () => {
                xVelocityContainer.children[1].innerText = "X " + xVelocityContainer.firstElementChild.value;
            });
            yVelocityContainer.firstElementChild.addEventListener("input", () => {
                yVelocityContainer.children[1].innerText = "Y " + yVelocityContainer.firstElementChild.value;
            });
            elasticConstantContainer.firstElementChild.addEventListener("input", () => {
                elasticConstantContainer.children[1].innerText = elasticConstantContainer.firstElementChild.value;
            });
            radiusContainer.firstElementChild.addEventListener("input", () => {
                radiusContainer.children[1].innerText = radiusContainer.firstElementChild.value;
            });
            realTimeAccelerationContainer.firstElementChild.addEventListener("input", () => {
                if (realTimeAccelerationContainer.firstElementChild.checked) {
                    realTimeAccelerationContainer.children[1].innerText = "ON";
                } else {
                    realTimeAccelerationContainer.children[1].innerText = "OFF";
                }
            });
            customXAccelerationContainer.firstElementChild.addEventListener("input", () => {
                customXAccelerationContainer.children[1].innerText = customXAccelerationContainer.firstElementChild.value;
            });
            customYAccelerationContainer.firstElementChild.addEventListener("input", () => {
                customYAccelerationContainer.children[1].innerText = customYAccelerationContainer.firstElementChild.value;
            });
            accelerationScaleContainer.firstElementChild.addEventListener("input", () => {
                accelerationScaleContainer.children[1].innerText = accelerationScaleContainer.firstElementChild.value;
            });

            //Execute initiation procedure
            setViewport();
            window.requestAnimationFrame(animateObjects);
        }
    </script>
</head>

<body onload="initiate();">
    <canvas id="canvas" class="canvas"></canvas>
    <div id="settingsDivision" class="interfaceDivision" style="display: flex;">
        <div class="interfaceControlsSector">
            <button id="showGlobalSettings" class="button">&#9874;</button>
            <button id="showAddObject" class="button">&#10010;</button>
            <button id="clearObjects" class="button">&#9760;</button>
        </div>
    </div>
    <div id="addObjectDivision" class="interfaceDivision" style="display: none;">
        <form class="interfaceDivisionSector">
            <div class="interfaceDivisionSectorItem">
                <label class="title">Velocity</label>
                <p class="titleDescription">
                    Sets the "speed" of the object. "Velocity" won't stay constant if an "acceleration" is applied.
                    "Velocity" is also affected by the "constant of elasticity" when colliding with the boundary.
                    Direction of "velocity" must be set using negative or positive values appropriately
                </p>
                <div id="xVelocity" class="inputContainer">
                    <input name="xVelocity" type="range" min="0" max="2000" step="1" value="0" class="input-range" />
                    <span class="display">X 0</span>
                </div>
                <div id="yVelocity" class="inputContainer">
                    <input name="yVelocity" type="range" min="0" max="2000" step="1" value="0" class="input-range" />
                    <span class="display">Y 0</span>
                </div>
            </div>
            <div class="interfaceDivisionSectorItem">
                <label class="title">Constant of Elasticity</label>
                <p class="titleDescription">
                    Sets the "bouncy-ness" of the object. "Constant of elasticity" affects the "velocity" when colliding
                    with the boundary
                </p>
                <div id="elasticConstant" class="inputContainer">
                    <input name="elasticConstant" type="range" min="0" max="1" step="0.1" value="1" class="input-range" />
                    <span class="display">1</span>
                </div>
            </div>
            <div class="interfaceDivisionSectorItem">
                <label class="title">Object Radius</label>
                <p class="titleDescription">
                    Sets the "size" of the object. The "size" won't affect the physical simulation in any way and is
                    only there for aesthetic purposes
                </p>
                <div id="radius" class="inputContainer">
                    <input name="radius" type="range" min="5" max="100" step="5" value="50" class="input-range" />
                    <span class="display">50</span>
                </div>
            </div>
        </form>
        <div class="interfaceControlsSector">
            <button id="addObject" class="button">&#10004;</button>
            <button id="cancelAddObject" class="button">&#10006;</button>
        </div>
    </div>
    <div id="globalSettingsDivision" class="interfaceDivision" style="display: none;">
        <form class="interfaceDivisionSector">
            <div class="interfaceDivisionSectorItem">
                <label class="title">Real-Time Acceleration</label>
                <p class="titleDescription">
                    Your device need to have an accelerometer for this to work. When the "real-time acceleration" is on, the engine will gather acceleration from the accelerometer and apply to all objects in the simulation. "Custom acceleration" is useless with "real-time acceleration"
                </p>
                <div id="realTimeAcceleration" class="inputContainer">
                    <input name="realTimeAcceleration" type="checkbox" class="input-check"/>
                    <span class="display">OFF</span>
                </div>
            </div>
            <div class="interfaceDivisionSectorItem">
                <label class="title">Custom Acceleration</label>
                <p class="titleDescription">
                    When the "real-time acceleration" is off, you can define your own acceleration for all the bodies in the simulation. This acceleration will stay constant.  "Custom acceleration" is useless with "real-time acceleration"
                </p>
                <div id="customXAcceleration" class="inputContainer">
                    <input name="customXAcceleration" type="range" min="0" max="10" step="1" value="0" class="input-range" />
                    <span class="display">X 0</span>
                </div>
                <div id="customYAcceleration" class="inputContainer">
                    <input name="customYAcceleration" type="range" min="0" max="10" step="1" value="0" class="input-range" />
                    <span class="display">Y 0</span>
                </div>
            </div>
            <div class="interfaceDivisionSectorItem">
                <label class="title">Acceleration Scale</label>
                <p class="titleDescription">
                    The device represents a meter(m) by a pixel(px). Therefore the objects seem to move very slowly in the simulation. You can adjust the "acceleration scale" to multiply all accelerations by the "acceleration scale" constant to make objects move faster
                </p>
                <div id="accelerationScale" class="inputContainer">
                    <input name="accelerationScale" type="range" min="1" max="1000" step="5" value="500" class="input-range" />
                    <span class="display">500</span>
                </div>
            </div>
        </form>
        <div class="interfaceControlsSector">
            <button id="applyGlobalSettings" class="button">&#10004;</button>
            <button id="cancelGlobalSettings" class="button">&#10006;</button>
        </div>
    </div>
    
</body>

</html>